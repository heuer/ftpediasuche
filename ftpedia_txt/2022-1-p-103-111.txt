
Computing

Computing

Single Track Gray Encoder mit fischertechnik
Florian Bauer
In diesem Beitrag wird ein prototypischer Aufbau eines Single Track Gray Encoders mit
fischertechnik vorgestellt. Dies ist ein multidisziplinÃ¤res Projekt, das aufzeigt, wie man mit
Hilfe von fischertechnik, etwas Elektronik und einem Mikrocontroller ein mathematisches
Modell in die RealitÃ¤t umsetzen und begreifbar machen kann.

Drehgeber
FÃ¼r die Messung von Positionen und Winkeln werden oft Drehgeber eingesetzt, die
auf unterschiedlichen physikalischen MessPrinzipien beruhen wie zum Beispiel
Widerstandsmessung, ZÃ¤hlung mechanischer, optischer oder magnetischer Impulse.
Man unterscheidet zwei Arten von Drehgebern:

einem Stromausfall die Position ohne Referenzfahrt korrekt ausgegeben wird.
Im Folgenden wollen wir uns einen 3-SpurAbsolut-Drehgeber ansehen. Die acht Digitalwerte sind als Schwarz-WeiÃŸ-Muster auf
einer Scheibe mit drei Spuren codiert (Abb.
1).

Inkremental-Drehgeber
Hier wird die Ã„nderung der Position gemessen. Bei den weit verbreiteten optischen
Drehgebern wird eine Encoderscheibe mit
einem Ã¤quidistanten Streifenmuster von
zwei versetzt angeordneten Lichtschranken
abgetastet. Durch ZÃ¤hlung und Auswertung
der Phasenlage der Lichtschranken-Impulse
kann die Position relativ zu einem Ausgangszustand bestimmt werden. Will man
eine Absolut-Position messen, muss zuerst
eine Referenzfahrt zu einem Endschalter
vorgenommen werden.
Diese Art von Drehgebern ist sehr oft in
Druckern zu finden. Ausrangierte Drucker
sind daher eine ideale Quelle fÃ¼r hochauflÃ¶sende Positions-Geber.
Absolut-Drehgeber
Bei diesen Drehgebern liegt die Rotationsposition zu jedem Zeitpunkt als Messwert
oder Digitalwort vor. Der Vorteil ist, dass
keine Referenzfahrt nÃ¶tig ist und auch nach


Jede Spur entspricht einer Bit-Position, ein
schwarzer Bereich kodiert eine 1 und ein
transparenter Bereich eine 0. Die Spuren
werden von einem Lichtschranken-Array
mit radial angeordneten Fotozellen abgetastet. Es lassen sich acht verschiedene Winkelwerte auflÃ¶sen; die AuflÃ¶sung betrÃ¤gt
damit 45Â° (= 360/8). FÃ¼r hÃ¶here WinkelauflÃ¶sungen benÃ¶tigt man mehr Spuren.



Um das Muster abzutasten verwendet man
eine Maske (45Â°-Segment). Die Ã–ffnungen
fÃ¼r die weiter innen liegenden Sensoren
sind kleiner als die fÃ¼r die Ã¤uÃŸeren, was bei
Sensoren, die kleiner sind als die MaskenÃ¶ffnung, zu Ablesefehlern fÃ¼hren kann. So
mÃ¼ssten bei einem Ãœbergang von 111 auf
000 alle drei Bitpositionen gleichzeitig
springen, was aber i. a. nicht mÃ¶glich ist, da
die Ã¤uÃŸeren Sensoren erst verzÃ¶gert schalten, was zu Pseudopositionen, also falschen
Winkelwerten fÃ¼hrt.
Abhilfe schaffen hier sogenannte Zyklische
Gray-Codes, bei denen sich zwischen den
Worten jeweils nur ein Bit Ã¤ndert, und das
auch bei Start- und End-Wort. Dies erreicht
man beispielsweise durch sogenannte
Binary Reflected Gray Codes.
Beispiel:
C3 = 000, 001, 011, 010, 110, 111, 101, 100
Eine zugehÃ¶rige Masken-Scheibe ist in

Letzteres ist im Hobby-Bereich sehr
schwierig zu realisieren.
FÃ¼r 12-bit-Werte ist eine WinkelauflÃ¶sung
von 0,0015Â° nÃ¶tig (= 360/4096). WÃ¼rde die
innerste Spur auf einem Kreis mit Radius 50
mm liegen, mÃ¼sste die MaskenÃ¶ffnung 0,08
mm klein sein. FÃ¼r eine MaskenÃ¶ffnung
von 1 mm brÃ¤uchte man fÃ¼r die innerste
Spur einen Radius von 667 mm. Um die
restlichen Spuren unterzubringen braucht
man noch mehr Platz oder entsprechend
kleine Masken und Sensoren.

Single Track Gray Codes
Um das Problem mit den spurabhÃ¤ngigen
Masken-/SensorgrÃ¶ÃŸen zu vermeiden ist es
wÃ¼nschenswert, die Sensoren entlang einer
einzigen Spur zu platzieren. Encoder mit
nur einer Spur werden auch als Single Track
Encoder bezeichnet.
Man braucht dazu einen sogenannten zyklischen Single Track Gray Code (STGC). Zu
gegebener BitlÃ¤nge ğ‘› lassen sich solche
STGC mit Periode ğ‘› Â· ğ‘¡ konstruieren (mit
ğ‘¡ gerade), sodass gilt [3]:
2 â‰¤ ğ‘¡ â‰¤ 2ğ‘›âˆ’

2(ğ‘›âˆ’3) âˆ’1

FÃ¼r ğ‘› = 5 gibt es beispielsweise einen Code
fÃ¼r ğ‘¡ = 6 mit 30 Werten und damit einer
WinkelauflÃ¶sung von 12Â°. Durch die zusÃ¤tzlich geforderte Eigenschaft kann nicht
der volle Bereich von 32 Werten (25) ausgeschÃ¶pft werden. DafÃ¼r hat man aber einen
30-stelligen zyklischen Single Track Gray
Code:
00100, 00101, 01101, 01111, 01110,
01100, 01000, 01010, 11010, 11110,
Code Encoder

Damit die Masken- und SensorgrÃ¶ÃŸe kein
Problem werden, muss man bei hÃ¶heren
AuflÃ¶sungen hinreichend groÃŸe CodeScheiben verwenden oder entsprechend
kleine Strukturen und Sensoren einsetzen.

11100, 11000, 10000, 10100, 10101,
11101, 11001, 10001, 00001, 01001,
01011, 11011, 10011, 00011, 00010,
10010, 10110, 10111, 00111, 00110
Dieser kann durch die folgende 30-BitSequenz mit Sensoren im Abstand von 6
Bits realisiert werden:
000000001111111111000110011100



Computing


(Zur Verdeutlichung sind fÃ¼r die ersten vier
Positionen die Ableseposition im Bitstring
und das ausgelesene BinÃ¤rwort farblich
markiert.)
Die zugehÃ¶rige Encoder-Scheibe fÃ¼r fÃ¼nf
Sensoren und die Masken-Scheibe sind in
STGC ist auf der Ã¤uÃŸeren Spur aufgebracht.
Die innere Spur ist nur eine Hilfe zur
leichteren Identifikation der Bit-Position:
Bei einem Absolut-Winkelencoder ist die
Masken-Scheibe fest mit dem Rahmen des
Encoders verbunden und die Code-Scheibe
dreht sich koaxial Ã¼ber der Masken-Scheibe. An den Aussparungen befinden sich die
Lichtschranken.
Generierung von Single Track Gray
Codes
Die Suche von STGC-Codes mit hÃ¶heren
BitlÃ¤ngen der Worte wird schnell kombinatorisch komplex. FÃ¼r die Erzeugung der
STGC-Sequenzen gibt es verschiedene
Verfahren. Eines soll im Folgenden kurz
beschrieben werden, wobei nicht nÃ¤her auf
die Mathematik eingegangen wird, die in
[1] genauer behandelt wird.

Ausgangspunkt ist eine sogenannte SeedCode-BinÃ¤rwort-Folge mit bestimmten Eigenschaften:
ï‚· Die Wortfolge bildet einen zyklischen
Gray-Code,
ï‚· alle Worte sind sogenannte LyndonWorte und
ï‚· alle Worte sind sogenannte Necklaces.
Ein Wort ist ein Lyndon-Wort, wenn es
(lexikographisch) kleiner ist als jede seiner
â€zyklischen Rotationenâ€œ.
Beispiel: 1010 ist kein Lyndon-Wort, da
0101 kleiner ist als 1010. 0011 hingegen ist
ein Lyndon-Wort, da es keine Rotation gibt,
die ein kleineres Wort erzeugt (0110, 1100
und 1001 sind alle grÃ¶ÃŸer).
Ein ğ‘›-Bit-Wort ist ein Necklace, wenn es
keine zyklische Rotation (mit 1. . ğ‘› âˆ’ 1
Rotationen) gibt, die das Wort auf sich
selber abbildet.
Beispiel: 0101 wird durch eine zweistufige
zyklische Rotation auf sich selbst abgebildet und ist daher kein Necklace. 0011 ist ein
Necklace, da es durch keine zyklische
Rotation auf sich selbst abgebildet werden
kann.




Als Ausgangsbasis fÃ¼r die Suche nach
Seed-Code-Worten erzeugt man eine Menge von Lyndon/Necklace-Worten. Aus dieser Menge bildet man Graphen, deren Knoten Worte aus dieser Menge sind und deren
Kanten Verbindungen zwischen Worten,
die sich nur in einem Bit unterscheiden â€“ die
eine Hamming-Distanz von 1 haben, also
â€grayâ€œ sind. Jede Seed-Code-Folge ist ein
geschlossener Pfad in diesem Graphen, bei
dem jeder Knoten mit genau zwei Nachbarknoten verbunden ist. Ein solcher geschlossener Pfad wird auch als â€Coil in the Boxâ€œ
bezeichnet (offene Pfade heiÃŸen â€Snake in
the Boxâ€œ und spielen fÃ¼r STGC keine
Rolle).

Graphen sind Verbindungen zwischen Worten, die sich um ein Bit unterscheiden.

Die Suche nach einer Seed-Code-Folge
kann beispielsweise mit Hilfe einer rekursiven Suche (Depth First Search) erfolgen,
die fÃ¼r ğ‘› >= 12 und lange Pfade ğ‘¡ = 300
schon lÃ¤nger dauern kann.

100001, 100101, 100111, 101111,
101011, 100011, 100010, 100000

Hat man nun eine Seed-Code-Folge, kann
daraus durch sukzessive Anwendung von
Bit-Rotationen ein Single Track Gray Code
aufgebaut werden.
FÃ¼r ğ‘› = 6 findet man z. B. folgende achtelementige Seed-Code-Folge:
000011, 001011, 001111, 011111,
010111, 000111, 000101, 000001
Diese Folge kann man zu einem 48-stelligen STGC erweitern:
000011, 001011, 001111, 011111,
010111, 000111, 000101, 000001

110000, 110010, 110011, 110111,
110101, 110001, 010001, 010000
011000, 011001, 111001, 111011,
111010, 111000, 101000, 001000
001100, 101100, 111100, 111101,
011101, 011100, 010100, 000100
000110, 010110, 011110, 111110,
101110, 001110, 001010, 000010
mit dem Bit-String fÃ¼r die Encoder-Scheibe:


In Abb. 4 ist ein Graph mit Seed-CodeWorten und einer zyklischen Seed-CodeFolge fÃ¼r ğ‘› = 6 dargestellt. Die Kanten des


0000000000011000000011100111110000
11111111111111
Die zugehÃ¶rige Encoder-Scheibe fÃ¼r sechs
Sensoren und die Masken-Scheibe sind in
7.5Â°.


Computing


Realisierung eines 6-BitEncoders mit 48 Stufen

ï‚· Ein Rad,
aufnimmt

Nachdem das Prinzip erlÃ¤utert wurde soll es
nun in ein fischertechnik-Modell umgesetzt
werden (Abb. 7). FÃ¼r den Encoder benÃ¶tigt
man:

Auch die Encoder-Scheibe wird mit doppelseitigem Klebeband auf einer Drehscheibe
60 aufgeklebt. Die Achse der EncoderScheibe wird in die Nabe der Maskenscheibe gesteckt.

ï‚· Eine transparente bedruckte Encoderund eine Masken-Scheibe:
Diese kann man herstellen, indem man das
Muster mit einem Laser- oder Desk-JetDrucker auf eine Transparentfolie druckt,
sodass der Durchmesser der Masken 75 mm
betrÃ¤gt.
Wenn die schwarzen Bereiche der Masken
nicht vollkommen deckend sind, kann man
sie mit einem schwarzen Edding-Stift oder
schwarzer Acrylfarbe nachbehandeln, was
bei BitlÃ¤ngen <= 9 noch gut funktioniert.
ï‚· Einen Halter fÃ¼r die Masken-Scheibe
Als Halter wird eine Drehscheibe 60
verwendet. Die hier nÃ¶tige sechszÃ¤hlige
Symmetrie kann mit 60Â°-fischertechnikWinkelsteinen leicht realisiert werden.
Die ausgeschnittene und in der Mitte gelochte Masken-Scheibe kann mit doppelseitigem Klebeband befestigt werden.

das

die

Encoder-Maske

ï‚· Lichtschranken bestehend aus LEDs und
LDRs oder Fototransistoren
FÃ¼r die Beleuchtung kÃ¶nnen 3-mm-LED, 5mm-LED oder fischertechnik-Lampen eingesetzt werden. Als Lichtschranken kÃ¶nnen
LDRs oder Fototransistoren verwendet
werden.
ï‚· Halterungen fÃ¼r Lichtschranken
Die Halterungen hÃ¤ngen davon ab, welche
Foto-Elemente man verwendet. 3-mm-LED
und 3-mm-Fototransistoren kÃ¶nnen z. B.
mit einer kleinen gedruckten AdapterhÃ¼lse
(Innendurchmesser 3 mm, AuÃŸendurchmesser 4 mm) in den Lagersteinen eingesetzt werden.
ï‚· Pick-Up-Elektronik fÃ¼r die Lichtschranken
Fototransistoren werden Ã¼ber 47-kÎ©WiderstÃ¤nde an +5V angeschlossen. Das




Signal leitet man am Kollektor des Transistors ab und fÃ¼hrt es an einen Digital-Pin
eines Mikrocontrollers. Ein abgedeckter
Fototransistor sperrt und das Signal betrÃ¤gt
+5V, ein beleuchteter Fototransistor schaltet durch und zieht das Signal gegen Masse
auf einen Wert < 1V.
ï‚· Ein Mikrocontroller fÃ¼r die Auswertung
und eventuelle Anzeige der Positionsbzw. Winkelwerte
FÃ¼r den hier vorgestellten Aufbau kommt
ein Arduino-Uno zum Einsatz. Der Uno
Ã¼bernimmt das Auslesen der Lichtschranken und der Winkel-Dekodierung Ã¼ber eine
Tabelle. Das Programm gibt die Winkelwerte auf der seriellen Schnittstelle aus.

ï‚· Optional eine 7-Segment-Anzeige um
die Winkelwerte darzustellen
DarÃ¼ber hinaus steuert der Arduino ein 7Segment-Display an, das die Werte Interrupt-gesteuert anzeigt.
Eine Schaltung, die auch einen 9-Bit-Encoder unterstÃ¼tzt, zeigt Abb. 6.
installierten Fototransistoren. Auf der
sichtbaren Drehscheibe 60 ist die CodeFolie aufgeklebt. Die Achse steckt in einer
identischen Drehscheibe 60 dahinter, die
am Rahmen fixiert ist und auf der die
Masken-Folie aufgeklebt ist.




Computing


Realisierung eines 9-Bit STGCEncoders mit 360 Stufen
In Abb. 8 ist ein 9-Bit-Encoder gezeigt, der
360 Stufen, also 1Â°-Schritte auflÃ¶st. ZugehÃ¶rige Encoder â€“ und Maskenscheiben sieht
man in Abb. 10.


Herzlichen Dank an Jan (juh), der mir kurzfristig
ein parametrisches Winkelstein-Modell in
FreeCAD zur VerfÃ¼gung gestellt hat [4]. Hier

Um die neunzÃ¤hlige Symmetrie zu realisieren wurde fÃ¼r diesen Encoder ein 40Â°Winkelstein in 3D-Druck angefertigt.2

muss ich mal meiner Begeisterung Ausdruck
verleihen, wie hilfsbereit die Leute im
fischertechnik-Forum sind.







Computing


LED-Emitterseite. Auf der rechten Seite
sind die Steckboards mit der AuswerteElektronik und der Arduino (oben rechts) zu
erkennen.
Da die HÃ¼lsen fÃ¼r die Fototransistoren nicht
ganz fest sitzen, wurden sie zusÃ¤tzlich mit
roten Lagersteinen fixiert. Oben rechts in
gibt den Blick auf eine HÃ¼lse mit einem
Fototransistor frei.

also einer AuflÃ¶sung von 0,1Â°, kann berechnet werden. Die Scheibe mÃ¼sste aber deutlich grÃ¶ÃŸer sein als die hier vorgestellten.
Von der Webseite zu dieser Ausgabe der
ft:pedia kÃ¶nnen die Beispielcodescheiben
und ein Programm fÃ¼r deren Erzeugung
heruntergeladen werden.

Referenzen
[1]

Moshe Schwartz, Tuvi Etzion: The
structure of single-track Gray codes.
IEEE Transactions on Information
Theory, 45, 1999, pp. 2383-2396.
10.1109/18.796379.

[2]

Darko Dimitrov, TomÃ¡s DvorÃ¡k, Petr
Gregor, Riste Å krekovski: Linear
time construction of a compressed
Gray code. European Journal of
Combinatorics, 2013.
10.1016/j.ejc.2012.07.015.

[3]

Georgie Botev: Single-Track Gray
Codes: An Efficiently Decodable
Maximal Period General
Construction. Github.com.

[4]

Jan Hanson (juh): Parametrischer
Winkelstein.

Ausblick
HÃ¶here AuflÃ¶sungen kÃ¶nnen mit grÃ¶ÃŸeren
BitlÃ¤ngen erreicht werden. Die Herausforderungen sind einerseits die Berechnung
von Seed-Code-Sequenzen und andererseits
die hohen Anforderungen an die kleinen
Strukturen der Encoder-Scheiben und bzw.
die sehr hohen AuflÃ¶sungen der Lichtschranken oder alternativ groÃŸen Scheibendurchmesser. Zudem muss auch der mechanische Aufbau stabiler um das Lagerspiel zu
verringern, das die effektiv erzielbare AuflÃ¶sung schnell verringert.
Eine 12-Bit-Decoder-Scheibe mit einer
MusterlÃ¤nge von 3600 (300 BinÃ¤rworten),


